<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://localhost:8000/pages/redux_store/">
    <link rel="shortcut icon" href="../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Redux Basics - Learning Journal</title>
    <link href="../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../js/jquery-3.2.1.min.js"></script>
    <script src="../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Redux Store", url: "#_top", children: [
              {title: "Create a store", url: "#create-a-store" },
              {title: "State", url: "#state" },
              {title: "Reducer", url: "#reducer" },
              {title: "Action", url: "#action" },
              {title: "Dispatch", url: "#dispatch" },
              {title: "Listeners", url: "#listeners" },
              {title: "Middleware", url: "#middleware" },
          ]},
        ];

    </script>
    <script src="../../js/base.js"></script>
      <script src="../../search/main.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav">
      <a href="../.." class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../.." class="btn btn-xs btn-link">
        Home
      </a>
    </div>
    
  </div>

    

    <h1 id="redux-store">Redux Store</h1>
<p>Redux is a state management framework that can be used with a number of different web technologies.<br>
In Redux, there is a single state object that's responsible for the entire state of your application. This means if you
had a React app with ten components, and each component had its own local state, the entire state of your app would be 
defined by a single state object housed in the Redux store. This is the first important principle to understand when
learning Redux: the Redux store is the single source of truth when it comes to application state.</p>
<h2 id="create-a-store">Create a store</h2>
<p>The Redux store is an object which holds and manages application state. There is a method called <code>createStore()</code> on the
Redux object, which you use to create the Redux store. This method takes a <code>reducer</code> function as a required argument.</p>
<pre><code class="language-javascript">import { createStore } from 'redux'

// Redux methods are available from a Redux object or imported from 'redux'
const store = createStore(reducer);
</code></pre>
<hr />
<h2 id="state">State</h2>
<p>The state refers to the data that represents the current state of your application. It is a plain JavaScript object 
that holds the data necessary for your application to function.<br>
The state object should be structured in a way that represents the different parts or slices of your application's data. 
Each slice of the state corresponds to a specific feature or domain of your application.</p>
<pre><code class="language-javascript">// The initial state of the store.
const state = {
    count: 0,
    turn: 0
};
</code></pre>
<p>This example has a state with two properties: <code>count</code> and <code>turn</code>. The 0 represent the initial data that 
the store holds.<br></p>
<p>The Redux store is read-only, This means that the data can not be updated. The only way to change the state is by 
<code>dispatching</code> an <code>action</code>, which ar then handled by a <code>reducer</code> to produce a new state.</p>
<h4 id="get-the-state">Get the state</h4>
<p>The Redux store object provides several methods that allow you to interact with it. For example, you can retrieve the 
current state held in the Redux store object with the <code>getState()</code> method.</p>
<pre><code class="language-javascript">const store = Redux.createStore(
  (state = 5) =&gt; state
);

const currentState = store.getState(); // 5
</code></pre>
<hr />
<h2 id="reducer">Reducer</h2>
<p>A <code>reducer</code> is a function that takes in the current <code>state</code> and an <code>action</code>, and returns the next <code>state</code> of the application.</p>
<p>A <code>reducer</code> is responsible for specifying how the application's <code>state</code> should change in response to different <code>actions</code> 
dispatched in the system. It follows the principles of immutability, meaning that it doesn't modify the existing state 
directly but instead creates a new state object that reflects the desired changes.</p>
<pre><code class="language-javascript">// A Simple reducer that returns a state.
const reducer = (state) =&gt; {
  return state;
}
</code></pre>
<pre><code class="language-javascript">// A  bit more complex reducer that checks which action is called and returns a new state object.
const counterReducer = (state = initialState, action) =&gt; {
    switch (action.type) { // 
        case 'INCREMENT':
            return {
                ...state, // The spread operator '...' copies all or part of the existing state object.  
                count: action.count + 1 // Replace the count item with a new one.
            };
        case 'DECREMENT':
            return {
                ...state,
                count: action.count - 1
            };
        default:
            return state;
    }
};
</code></pre>
<h4 id="combine-reducers">Combine reducers</h4>
<p>When the state of your app begins to grow more complex, it may be tempting to divide <code>state</code> into multiple pieces instead.
Remember that all app state is held in a single <code>state object</code> in the <code>store</code>. Therefore, Redux provides <code>reducer composition</code>
as a solution for a complex state model. You define multiple reducers to handle different pieces of your 
application's state, then compose these reducers together into one <code>root reducer</code>. The root reducer is then passed into 
the Redux <code>createStore()</code> method.</p>
<pre><code class="language-javascript">import { createStore, combineReducers } from 'redux';

// Reducers for different slices of the state
const taskReducer = (state = [], action) =&gt; {
    // Reducer logic for tasks
    return state;
};

const userReducer = (state = {}, action) =&gt; {
    // Reducer logic for users
    return state;
};

// Combine the reducers into a root reducer
const rootReducer = combineReducers({
    tasks: taskReducer,
    users: userReducer
});

// Create the Redux store with the root reducer
const store = createStore(rootReducer);
</code></pre>
<hr />
<h2 id="action">Action</h2>
<p>Since Redux is a state management framework, updating state is one of its core tasks. In Redux, all state updates are
triggered by <code>dispatching actions</code>. An action is simply a <code>JavaScript object</code> that contains information about an action 
event that has occurred. The Redux store receives these action objects, then updates its state accordingly. Sometimes 
a Redux action also carries some data. For example, the action carries a username after a user logs in. While the data
is optional, actions must carry a <code>type</code> property that specifies the 'type' of action that occurred.</p>
<pre><code class="language-javascript">const LOGIN = 'LOGIN';
const INCREMENT = 'INCREMENT';

// Action that carries no data.
const loginAction = {
    type: LOGIN
};

// Action that carries data
const incrementAction = {
    type: INCREMENT,
    payload: {
        value: 1
    }
};
</code></pre>
<p>The type properties are set to <code>'LOGIN''</code> and <code>'INCREMENT''</code>, this indicates intentions to perform certain operations.
The <code>incrementAction</code> also has the property <code>payload</code> which contains additional data related to that action. In this case 
the value by which the state should be incremented.</p>
<h4 id="send-data-with-an-action-to-the-store">Send data with an action to the store</h4>
<p>To send data along with your actions, you can create an arrow function with an argument. This argument can be set inside 
the return object alongside the type.</p>
<pre><code class="language-javascript">const ADD_NOTE = 'ADD_NOTE';

const addNoteText = (note) =&gt; {
  return {
      type: ADD_NOTE,
      text: note 
    };
};
</code></pre>
<hr />
<h2 id="dispatch">Dispatch</h2>
<p>the <code>dispatch</code> is used to send <code>actions</code> to the store, triggering the process of updating the application state.
The dispatch function accepts an action object as its parameter and forwards that action to the appropriate <code>reducer</code>.
The reducers then handle the action and update the state based on the logic defined within them.</p>
<pre><code class="language-javascript">const ADD_NOTE = 'ADD_NOTE';

const addNoteText = (note) =&gt; {
    return {
        type: ADD_NOTE,
        text: note
    };
};

store.dispatch(addNoteText('This is a note'));
</code></pre>
<hr />
<h2 id="listeners">Listeners</h2>
<h4 id="subscribe">Subscribe</h4>
<p>The <code>store.subscribe()</code> method is used to add a listener function that gets called whenever the state in the Redux store
changes. It allows components or other parts of your application to be notified of state updates and respond accordingly.</p>
<p>The <code>subscribe()</code> method takes a listener function as its argument. The listener function will be invoked whenever 
there is a state change in the store. The listener does not receive any parameters, but it can access the current state
by calling <code>store.getState()</code>.</p>
<pre><code class="language-javascript">const store = createStore(reducer);

const listener = () =&gt; {
  const state = store.getState();
  console.log('Current state:', state);
  // Perform additional actions based on the state change
};

store.subscribe(listener);
</code></pre>
<h4 id="unsubscribe">Unsubscribe</h4>
<p>It's important to note that <code>store.subscribe()</code> returns a function that can be used to unsubscribe the listener when it 
is no longer needed. Calling the returned <code>unsubscribe()</code> function will remove the listener from being notified of state changes.</p>
<pre><code class="language-javascript">const unsubscribe = store.subscribe(listener);

// Later, to unsubscribe the listener
unsubscribe();
</code></pre>
<p>Unsubscribing the listener is useful when components are unmounted or when you no longer need to listen for state changes.
It helps prevent memory leaks and unnecessary updates.</p>
<h2 id="middleware">Middleware</h2>
<p>To apply middleware to the Redux store and add additional functionality, you can use the applyMiddleware() function 
provided by Redux. Middleware intercepts the actions dispatched to the store before they reach the reducers, allowing 
you to modify or enhance the behavior of the store.</p>
<pre><code class="language-javascript">import { createStore, applyMiddleware } from 'redux';
import thunk from 'redux-thunk'; // Example middleware

const rootReducer = (state, action) =&gt; {
  // Reducer logic
};

const store = createStore(rootReducer, applyMiddleware(thunk));
</code></pre>
<p>By applying middleware to the store, you can achieve a variety of functionalities, such as:</p>
<ul>
<li>Logging: Middleware can log actions, state changes, or other information for debugging purposes or logging application behavior. </li>
<li>Asynchronous Operations: Middleware can handle asynchronous tasks, such as making API requests, by intercepting actions and dispatching additional actions based on the results. </li>
<li>Modifying Actions: Middleware can modify or transform actions before they reach the reducers, allowing you to add additional data, conditionally dispatch actions, or implement custom behavior.</li>
</ul>
<p>To add additional middleware, you can simply pass them as arguments to applyMiddleware():</p>
<pre><code class="language-javascript">import { createStore, applyMiddleware } from 'redux';
import thunk from 'redux-thunk';
import logger from 'redux-logger'; // Another example middleware

const store = createStore(rootReducer, applyMiddleware(thunk, logger));
</code></pre>
<p>In this example, both thunk and logger middleware are applied to the store. The order of middleware matters as they are 
executed in the order they are passed to applyMiddleware().</p>
<h4 id="custom-middleware">Custom middleware</h4>
<p>you can create your own middleware for Redux. Custom middleware allows you to add specific functionality or behavior to the Redux store based on your application's requirements.</p>
<p>Middleware in Redux is essentially a function that takes three arguments: <code>store</code>, <code>next</code>, and <code>action</code>. It intercepts actions 
dispatched to the store and can modify, dispatch new actions, or perform other operations before passing them along 
to the next middleware or reducers.</p>
<pre><code class="language-javascript">const myCustomMiddleware = (store) =&gt; (next) =&gt; (action) =&gt; {
  // Perform any custom logic or operations before the action reaches the reducer

  // You can access the current state using store.getState()
  const currentState = store.getState();

  // You can dispatch additional actions based on conditions
  if (action.type === 'SOME_ACTION') {
    store.dispatch({ type: 'ANOTHER_ACTION', payload: 'Some data' });
  }

  // Call next(action) to pass the action to the next middleware or reducers
  const result = next(action);

  // Perform any custom logic or operations after the action has been processed

  return result;
};
</code></pre>
<p>By creating your own middleware, you have full control over the behavior of the store and can add custom functionality, 
such as authentication handling, caching, analytics, or any other application-specific requirements.</p>
<h4 id="source">source</h4>
<ul>
<li><a href="https://www.freecodecamp.org/learn/front-end-development-libraries/#redux">freeCodeCamp</a></li>
</ul>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav">
      <a href="../.." class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../.." class="btn btn-xs btn-link">
        Home
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="col-md-12 wm-page-content">
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="None">Windmill Dark</a> theme by None (noraj).</p>
</footer>

</body>
</html>